package org.gephi.viz.engine.jogl.pipeline.text;

import com.jogamp.opengl.GL;
import com.jogamp.opengl.GL2ES2;

import io.github.humbleui.skija.*;
import io.github.humbleui.skija.paragraph.*;

import org.gephi.graph.api.Node;
import org.gephi.graph.api.Rect2D;
import org.gephi.viz.engine.VizEngine;
import org.gephi.viz.engine.jogl.JOGLRenderingTarget;
import org.gephi.viz.engine.pipeline.PipelineCategory;
import org.gephi.viz.engine.pipeline.RenderingLayer;
import org.gephi.viz.engine.spi.Renderer;
import org.gephi.viz.engine.structure.GraphIndex;
import org.gephi.viz.engine.util.gl.Constants;
import org.gephi.viz.engine.util.structure.NodesCallback;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.EnumSet;
import java.util.LinkedHashMap;
import java.util.Map;

/**
 * NOTE: ALL OF THIS CODE IS GENERATED BY CHATGPT JUST TO QUICK-TEST Skija.
 * AT THE MOMENT IS MUCH SLOWER THAN Jzy3d text renderer but can look crisper.
 */
@SuppressWarnings("rawtypes")
public class NodeLabelRenderer implements Renderer<JOGLRenderingTarget> {
    public static final EnumSet<RenderingLayer> LAYERS = EnumSet.of(RenderingLayer.FRONT1);

    private final VizEngine engine;
    private final NodesCallback nodesCallback = new NodesCallback();

    // Skia text shaping
    private FontCollection fontCollection;
    private final ParagraphStyle paragraphStyle = new ParagraphStyle();

    // Cache label textures by (text, pxHeightBucket, color, rasterScale)
    private final LabelCache cache = new LabelCache(512);

    // Tiny GL pipeline for textured quad
    private int prog = 0;
    private int vbo = 0;
    private int aPos = 0;
    private int aUV  = 1;
    private int uTex = 0;

    // Scratch
    private final float[] proj = new float[16];
    private final float[] view = new float[16];
    private final float[] mvp  = new float[16];

    // ---- Performance knobs ----
    private static final float  LABEL_HEIGHT_TO_DIAMETER = 0.40f;
    private static final float  LABEL_MAX_WIDTH_FILL     = 0.90f;
    private static final int    SIZE_BUCKET_PX           = 8;    // coarser buckets -> more cache hits
    private static final int    MAX_LABEL_PX_HEIGHT      = 96;   // clamp big labels
    private static final float  RASTER_SCALE             = 0.6f; // render at 60% of logical px, reduce for less crisp text
    private static final boolean USE_MIPMAPS             = true; // nicer when zooming out

    public NodeLabelRenderer(VizEngine engine) {
        this.engine = engine;
    }

    @Override
    public void init(JOGLRenderingTarget target) {
        fontCollection = new FontCollection();
        fontCollection.setDefaultFontManager(FontMgr.getDefault());

        final GL2ES2 gl = target.getDrawable().getGL().getGL2ES2();
        prog = buildProgram(gl, VERT_SRC, FRAG_SRC);
        aPos = gl.glGetAttribLocation(prog, "aPos");
        aUV  = gl.glGetAttribLocation(prog, "aUV");
        uTex = gl.glGetUniformLocation(prog, "uTex");

        final int[] ids = new int[1];
        gl.glGenBuffers(1, ids, 0);
        vbo = ids[0];
        gl.glBindBuffer(GL.GL_ARRAY_BUFFER, vbo);
        gl.glBufferData(GL.GL_ARRAY_BUFFER, 16 * Float.BYTES, null, GL.GL_DYNAMIC_DRAW);
        gl.glBindBuffer(GL.GL_ARRAY_BUFFER, 0);
    }

    @Override
    public void worldUpdated(JOGLRenderingTarget target) {
        final GraphIndex gi = engine.getGraphIndex();
        final Rect2D viewBoundaries = engine.getViewBoundaries();
        gi.getVisibleNodes(nodesCallback, viewBoundaries);
    }

    @Override
    public void render(JOGLRenderingTarget target, RenderingLayer layer) {
        final GL2ES2 gl = target.getDrawable().getGL().getGL2ES2();

        engine.getProjectionMatrix().get(proj);
        engine.getViewMatrix().get(view);
        multiply4x4(proj, view, mvp);

        final int W = engine.getWidth();
        final int H = engine.getHeight();
        if (W <= 0 || H <= 0) return;

        // Premultiplied alpha blending
        gl.glEnable(GL.GL_BLEND);
        gl.glBlendFunc(GL.GL_ONE, GL.GL_ONE_MINUS_SRC_ALPHA);
        gl.glDisable(GL.GL_DEPTH_TEST);

        gl.glUseProgram(prog);
        gl.glUniform1i(uTex, 0);
        gl.glActiveTexture(GL.GL_TEXTURE0);

        gl.glBindBuffer(GL.GL_ARRAY_BUFFER, vbo);
        gl.glEnableVertexAttribArray(aPos);
        gl.glEnableVertexAttribArray(aUV);
        gl.glVertexAttribPointer(aPos, 2, GL.GL_FLOAT, false, 4 * Float.BYTES, 0);
        gl.glVertexAttribPointer(aUV,  2, GL.GL_FLOAT, false, 4 * Float.BYTES, 2 * Float.BYTES);

        final Node[] nodes = nodesCallback.getNodesArray();
        final int count = nodesCallback.getCount();

        for (int i = 0; i < count; i++) {
            final Node n = nodes[i];
            final String text = n.getLabel();
            if (text == null || text.isEmpty()) continue;

            // world -> NDC
            final float[] clip = mulMV(mvp, n.x(), n.y(), 0f, 1f);
            if (clip[3] == 0f) continue;
            final float ndcX = clip[0] / clip[3];
            final float ndcY = clip[1] / clip[3];

            // NDC -> screen (top-left)
            final float cx = (ndcX * 0.5f + 0.5f) * W;
            final float cy = (1f - (ndcY * 0.5f + 0.5f)) * H;

            // node diameter in px
            final float ppwu = pixelsPerWorldUnitAt(n.x(), n.y(), mvp, W, H);
            final float nodeDiameterPx = Math.max(1f, 2f * n.size() * ppwu) * 4f;

            // label height (bucketed + clamped)
            int pxHeight = Math.round(nodeDiameterPx * LABEL_HEIGHT_TO_DIAMETER);
            pxHeight = Math.min(MAX_LABEL_PX_HEIGHT, Math.max(10, bucketPx(pxHeight)));

            final int argb = 0xff000000;

            // get texture: logicalW/H are *full* metrics; texW/H are smaller by RASTER_SCALE
            final LabelTex tex = cache.getOrCreate(gl, fontCollection, paragraphStyle, text,
                    pxHeight, argb, RASTER_SCALE, USE_MIPMAPS);

            // clamp draw width to node diameter
            final float maxW = nodeDiameterPx * LABEL_MAX_WIDTH_FILL;
            final float drawW = Math.min(tex.logicalW, maxW);
            final float scale = tex.logicalW > 0 ? drawW / tex.logicalW : 1f;
            final float drawH = tex.logicalH * scale;

            // center quad at (cx, cy)
            final float x0 = cx - drawW * 0.5f;
            final float y0 = cy - drawH * 0.5f;
            final float x1 = x0 + drawW;
            final float y1 = y0 + drawH;

            // to NDC
            final float x0n =  (x0 / W) * 2f - 1f;
            final float x1n =  (x1 / W) * 2f - 1f;
            final float y0n =  1f - (y0 / H) * 2f;
            final float y1n =  1f - (y1 / H) * 2f;

            final float[] verts = {
                    x0n, y0n,  0f, 1f,
                    x0n, y1n,  0f, 0f,
                    x1n, y0n,  1f, 1f,
                    x1n, y1n,  1f, 0f
            };
            gl.glBufferSubData(GL.GL_ARRAY_BUFFER, 0, verts.length * Float.BYTES, FloatArray.asDirect(verts));

            gl.glBindTexture(GL.GL_TEXTURE_2D, tex.id);
            gl.glDrawArrays(GL.GL_TRIANGLE_STRIP, 0, 4);
        }

        gl.glDisableVertexAttribArray(aPos);
        gl.glDisableVertexAttribArray(aUV);
        gl.glBindBuffer(GL.GL_ARRAY_BUFFER, 0);
        gl.glBindTexture(GL.GL_TEXTURE_2D, 0);
        gl.glUseProgram(0);
    }

    @Override public EnumSet<RenderingLayer> getLayers() { return LAYERS; }
    @Override public int getOrder() { return Constants.RENDERING_ORDER_LABELS; }
    @Override public String getCategory() { return PipelineCategory.NODE_LABEL; }
    @Override public int getPreferenceInCategory() { return 0; }
    @Override public String getName() { return "Node Labels (Skija cached, downscaled)"; }

    // ---------- GL mini-pipeline ----------

    private static int buildProgram(GL2ES2 gl, String vsSrc, String fsSrc) {
        int vs = gl.glCreateShader(GL2ES2.GL_VERTEX_SHADER);
        gl.glShaderSource(vs, 1, new String[]{vsSrc}, new int[]{vsSrc.length()}, 0);
        gl.glCompileShader(vs); checkShader(gl, vs);

        int fs = gl.glCreateShader(GL2ES2.GL_FRAGMENT_SHADER);
        gl.glShaderSource(fs, 1, new String[]{fsSrc}, new int[]{fsSrc.length()}, 0);
        gl.glCompileShader(fs); checkShader(gl, fs);

        int prog = gl.glCreateProgram();
        gl.glAttachShader(prog, vs);
        gl.glAttachShader(prog, fs);
        gl.glBindAttribLocation(prog, 0, "aPos");
        gl.glBindAttribLocation(prog, 1, "aUV");
        gl.glLinkProgram(prog); checkProgram(gl, prog);
        gl.glDeleteShader(vs); gl.glDeleteShader(fs);
        return prog;
    }

    private static void checkShader(GL2ES2 gl, int s) {
        int[] ok = new int[1];
        gl.glGetShaderiv(s, GL2ES2.GL_COMPILE_STATUS, ok, 0);
        if (ok[0] == GL.GL_FALSE) {
            int[] len = new int[1];
            gl.glGetShaderiv(s, GL2ES2.GL_INFO_LOG_LENGTH, len, 0);
            byte[] log = new byte[len[0]];
            gl.glGetShaderInfoLog(s, len[0], null, 0, log, 0);
            throw new RuntimeException("Shader compile error: " + new String(log));
        }
    }

    private static void checkProgram(GL2ES2 gl, int p) {
        int[] ok = new int[1];
        gl.glGetProgramiv(p, GL2ES2.GL_LINK_STATUS, ok, 0);
        if (ok[0] == GL.GL_FALSE) {
            int[] len = new int[1];
            gl.glGetProgramiv(p, GL2ES2.GL_INFO_LOG_LENGTH, len, 0);
            byte[] log = new byte[len[0]];
            gl.glGetProgramInfoLog(p, len[0], null, 0, log, 0);
            throw new RuntimeException("Program link error: " + new String(log));
        }
    }

    private static final String VERT_SRC =
            "attribute vec2 aPos;\n" +
                    "attribute vec2 aUV;\n" +
                    "varying vec2 vUV;\n" +
                    "void main(){ vUV = aUV; gl_Position = vec4(aPos, 0.0, 1.0); }\n";

    private static final String FRAG_SRC =
            "precision mediump float;\n" +
                    "uniform sampler2D uTex;\n" +
                    "varying vec2 vUV;\n" +
                    "void main(){ gl_FragColor = texture2D(uTex, vUV); }\n";

    // ---------- Skia label cache with downscaled raster ----------

    private static final class LabelTex {
        final int id;            // GL texture id
        final int texW, texH;    // actual texture size (downscaled)
        final float logicalW;    // full logical width (px)
        final float logicalH;    // full logical height (px)
        LabelTex(int id, int texW, int texH, float logicalW, float logicalH) {
            this.id = id; this.texW = texW; this.texH = texH; this.logicalW = logicalW; this.logicalH = logicalH;
        }
    }

    private static final class LabelCache {
        private final int max;
        private final Map<String, LabelTex> map = new LinkedHashMap<>(128, 0.75f, true) {
            @Override protected boolean removeEldestEntry(Map.Entry<String, LabelTex> e) {
                // No GL context here; textures are deleted via clear(gl) or explicit evict path if you add one.
                return size() > max;
            }
        };

        LabelCache(int maxEntries) { this.max = maxEntries; }

        private static String key(String text, int pxHeight, int argb, float scale) {
            return pxHeight + "|" + argb + "|" + scale + "|" + text;
        }

        LabelTex getOrCreate(GL2ES2 gl, FontCollection fonts, ParagraphStyle paraStyle,
                             String text, int pxHeight, int argbColor, float rasterScale, boolean useMipmaps) {
            final String k = key(text, pxHeight, argbColor, rasterScale);
            LabelTex tex = map.get(k);
            if (tex != null) return tex;

            // Build paragraph at full logical px height
            final TextStyle ts = new TextStyle();
            ts.setFontSize(pxHeight);
            ts.setColor(argbColor);
            ts.setFontFamilies(new String[]{ "Noto Sans", "Arial", "Segoe UI Emoji" });

            final ParagraphBuilder pb = new ParagraphBuilder(paraStyle, fonts);
            pb.pushStyle(ts);
            pb.addText(text);
            final Paragraph p = pb.build();
            p.layout(Float.MAX_VALUE);

            final float logicalW = (float) Math.ceil(p.getMaxIntrinsicWidth());
            final float logicalH = (float) Math.ceil(p.getHeight());

            // Downscaled raster size
            final int texW = Math.max(1, Math.round(logicalW * rasterScale));
            final int texH = Math.max(1, Math.round(logicalH * rasterScale));

            // Raster at smaller resolution: scale canvas so the paragraph fits texW/texH
            final Surface surface = Surface.makeRasterN32Premul(texW, texH);
            final Canvas canvas = surface.getCanvas();
            canvas.clear(0x00000000);
            canvas.scale(rasterScale, rasterScale); // draw smaller
            p.paint(canvas, 0, 0);

            final Image img = surface.makeImageSnapshot();
            final Pixmap pm = new Pixmap();
            img.peekPixels(pm); // premultiplied top-down RGBA

            // Make a tight bottom-up buffer for GL
            final int rowBytes = pm.getRowBytes();
            final ByteBuffer src = pm.getBuffer();
            final ByteBuffer tight = ByteBuffer.allocateDirect(texW * texH * 4).order(ByteOrder.nativeOrder());
            final byte[] row = new byte[texW * 4];
            for (int y = 0; y < texH; y++) {
                src.position(y * rowBytes).get(row, 0, texW * 4);
                tight.position((texH - 1 - y) * texW * 4).put(row, 0, texW * 4);
            }
            tight.rewind();

            // Upload to GL (premultiplied)
            final int[] id = new int[1];
            gl.glGenTextures(1, id, 0);
            gl.glBindTexture(GL.GL_TEXTURE_2D, id[0]);
            gl.glPixelStorei(GL.GL_UNPACK_ALIGNMENT, 1);
            gl.glTexParameteri(GL.GL_TEXTURE_2D, GL.GL_TEXTURE_MIN_FILTER,
                    useMipmaps ? GL.GL_LINEAR_MIPMAP_LINEAR : GL.GL_LINEAR);
            gl.glTexParameteri(GL.GL_TEXTURE_2D, GL.GL_TEXTURE_MAG_FILTER, GL.GL_LINEAR);
            gl.glTexParameteri(GL.GL_TEXTURE_2D, GL.GL_TEXTURE_WRAP_S, GL.GL_CLAMP_TO_EDGE);
            gl.glTexParameteri(GL.GL_TEXTURE_2D, GL.GL_TEXTURE_WRAP_T, GL.GL_CLAMP_TO_EDGE);
            gl.glTexImage2D(GL.GL_TEXTURE_2D, 0, GL.GL_RGBA, texW, texH, 0, GL.GL_RGBA, GL.GL_UNSIGNED_BYTE, tight);
            if (useMipmaps) {
                gl.glGenerateMipmap(GL.GL_TEXTURE_2D);
            }
            gl.glBindTexture(GL.GL_TEXTURE_2D, 0);

            tex = new LabelTex(id[0], texW, texH, logicalW, logicalH);
            map.put(k, tex);

            pm.close(); img.close(); surface.close();
            return tex;
        }

        void clear(GL2ES2 gl) {
            for (LabelTex t : map.values()) {
                gl.glDeleteTextures(1, new int[]{t.id}, 0);
            }
            map.clear();
        }
    }

    // ---------- math & utils ----------

    private static void multiply4x4(float[] a, float[] b, float[] out) {
        for (int c = 0; c < 4; c++) {
            int k = c * 4;
            float b0 = b[k], b1 = b[k+1], b2 = b[k+2], b3 = b[k+3];
            out[k]   = a[0]*b0 + a[4]*b1 + a[8 ]*b2 + a[12]*b3;
            out[k+1] = a[1]*b0 + a[5]*b1 + a[9 ]*b2 + a[13]*b3;
            out[k+2] = a[2]*b0 + a[6]*b1 + a[10]*b2 + a[14]*b3;
            out[k+3] = a[3]*b0 + a[7]*b1 + a[11]*b2 + a[15]*b3;
        }
    }
    private static float[] mulMV(float[] m, float x, float y, float z, float w) {
        return new float[]{
                m[0]*x + m[4]*y + m[8 ]*z + m[12]*w,
                m[1]*x + m[5]*y + m[9 ]*z + m[13]*w,
                m[2]*x + m[6]*y + m[10]*z + m[14]*w,
                m[3]*x + m[7]*y + m[11]*z + m[15]*w
        };
    }
    private static float pixelsPerWorldUnitAt(float x, float y, float[] mvp, int vpW, int vpH) {
        final float[] p0 = mulMV(mvp, x,   y,   0f, 1f);
        final float[] p1 = mulMV(mvp, x+1, y,   0f, 1f);
        final float nx0 = p0[0]/p0[3], ny0 = p0[1]/p0[3];
        final float nx1 = p1[0]/p1[3], ny1 = p1[1]/p1[3];
        final float sx0 = (nx0*0.5f+0.5f)*vpW, sy0 = (1f - (ny0*0.5f+0.5f))*vpH;
        final float sx1 = (nx1*0.5f+0.5f)*vpW, sy1 = (1f - (ny1*0.5f+0.5f))*vpH;
        return (float)Math.hypot(sx1 - sx0, sy1 - sy0);
    }
    private static int bucketPx(int px) {
        return Math.max(8, (px + SIZE_BUCKET_PX/2) / SIZE_BUCKET_PX * SIZE_BUCKET_PX);
    }
    private static int ensureARGB(int rgba) {
        int a = (rgba >>> 24) & 0xFF, r = (rgba >>> 16) & 0xFF, g = (rgba >>> 8) & 0xFF, b = rgba & 0xFF;
        return (a << 24) | (r << 16) | (g << 8) | b;
    }
    private static final class FloatArray {
        static ByteBuffer asDirect(float[] f) {
            ByteBuffer bb = ByteBuffer.allocateDirect(f.length * Float.BYTES).order(ByteOrder.nativeOrder());
            bb.asFloatBuffer().put(f);
            return bb;
        }
    }

    public void dispose(JOGLRenderingTarget target) {
        final GL2ES2 gl = target.getDrawable().getGL().getGL2ES2();
        cache.clear(gl);
        if (vbo != 0) { gl.glDeleteBuffers(1, new int[]{vbo}, 0); vbo = 0; }
        if (prog != 0) { gl.glDeleteProgram(prog); prog = 0; }
    }
}
