package org.gephi.viz.engine.jogl.pipeline.text;

import com.jogamp.opengl.GL;
import com.jogamp.opengl.GL2ES2;

import io.github.humbleui.skija.*;
import io.github.humbleui.skija.paragraph.*;

import org.gephi.graph.api.Node;
import org.gephi.graph.api.Rect2D;
import org.gephi.viz.engine.VizEngine;
import org.gephi.viz.engine.jogl.JOGLRenderingTarget;
import org.gephi.viz.engine.pipeline.PipelineCategory;
import org.gephi.viz.engine.pipeline.RenderingLayer;
import org.gephi.viz.engine.spi.Renderer;
import org.gephi.viz.engine.status.GraphSelection;
import org.gephi.viz.engine.structure.GraphIndex;
import org.gephi.viz.engine.util.gl.Constants;
import org.gephi.viz.engine.util.structure.NodesCallback;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.*;

import static com.jogamp.opengl.GL.*;
import static com.jogamp.opengl.GL.GL_SRC_ALPHA;

/**
 * NOTE: ALL OF THIS CODE IS GENERATED BY GPT-5. Need to clean-up and properly understand it.
 *
 * Batched node label renderer using a texture atlas.
 *
 * - Labels packed into atlas pages and drawn in batches (one draw call per page).
 * - Robust bounds checks + defensive programming to avoid crashes.
 * - Cache keys bucket by height & color & rasterScale; atlas allocates lazily.
 */
@SuppressWarnings("rawtypes")
public class NodeLabelRenderer implements Renderer<JOGLRenderingTarget> {
    public static final EnumSet<RenderingLayer> LAYERS = EnumSet.of(RenderingLayer.FRONT1);

    private final VizEngine engine;
    private final NodesCallback nodesCallback = new NodesCallback();

    // Skia text shaping
    private FontCollection fontCollection;
    private final ParagraphStyle paragraphStyle = new ParagraphStyle();

    // Cache + Atlas
    private final LabelAtlasCache cache = new LabelAtlasCache( /*maxEntries*/ 4096, /*pageW*/ 2048, /*pageH*/ 2048, /*padding*/ 1);

    // Tiny GL pipeline for textured quad
    private int prog = 0;
    private int vbo = 0;
    private int aPos = 0;
    private int aUV  = 1;
    private int uTex = 0;

    // Scratch
    private final float[] proj = new float[16];
    private final float[] view = new float[16];
    private final float[] mvp  = new float[16];

    // ---- Performance knobs ----
    private static final float  LABEL_HEIGHT_TO_DIAMETER = 0.40f;
    private static final float  LABEL_MAX_WIDTH_FILL     = 0.90f;
    private static final int    SIZE_BUCKET_PX           = 8;    // coarser buckets -> more cache hits
    private static final int    MAX_LABEL_PX_HEIGHT      = 96;   // clamp big labels
    private static final float  RASTER_SCALE             = 0.6f; // render at 60% of logical px, reduce for less crisp text with smaller textures
    private static final boolean USE_MIPMAPS             = true; // nicer when zooming out

    // Per-vertex layout: 4 floats (x, y, u, v). We draw triangles: 6 verts/quad.
    private static final int FLOATS_PER_VERTEX = 4;

    public NodeLabelRenderer(VizEngine engine) { this.engine = engine; }

    @Override
    public void init(JOGLRenderingTarget target) {
        fontCollection = new FontCollection();
        fontCollection.setDefaultFontManager(FontMgr.getDefault());

        final GL2ES2 gl = target.getDrawable().getGL().getGL2ES2();
        if (gl == null) return;
        prog = buildProgram(gl, VERT_SRC, FRAG_SRC);
        aPos = gl.glGetAttribLocation(prog, "aPos");
        aUV  = gl.glGetAttribLocation(prog, "aUV");
        uTex = gl.glGetUniformLocation(prog, "uTex");

        final int[] ids = new int[1];
        gl.glGenBuffers(1, ids, 0);
        vbo = ids[0];
        gl.glBindBuffer(GL.GL_ARRAY_BUFFER, vbo);
        gl.glBufferData(GL.GL_ARRAY_BUFFER, 1024, null, GL2ES2.GL_STREAM_DRAW); // small initial, will orphan & grow
        gl.glBindBuffer(GL.GL_ARRAY_BUFFER, 0);
    }

    @Override
    public void worldUpdated(JOGLRenderingTarget target) {
        final GraphIndex gi = engine.getGraphIndex();
        final Rect2D viewBoundaries = engine.getViewBoundaries();
        gi.getVisibleNodes(nodesCallback, viewBoundaries);
    }

    private final int[] intData = new int[1];
    private final byte[] booleanData = new byte[1];

    @Override
    public void render(JOGLRenderingTarget target, RenderingLayer layer) {
        final GraphSelection selection = engine.getGraphSelection();
        final boolean someSelection = selection.someNodesOrEdgesSelection();

        final GL2ES2 gl = target.getDrawable().getGL().getGL2ES2();

        engine.getProjectionMatrix().get(proj);
        engine.getViewMatrix().get(view);
        multiply4x4(proj, view, mvp);

        final int W = Math.max(0, engine.getWidth());
        final int H = Math.max(0, engine.getHeight());
        if (W <= 0 || H <= 0) return;

        gl.glGetBooleanv(GL_BLEND, booleanData, 0);
        gl.glGetIntegerv(GL_BLEND_DST_ALPHA, intData, 0);


        // Premultiplied alpha blending
        final boolean blendEnabled = booleanData[0] > 0;
        final int blendFunc = intData[0];

        if (!blendEnabled) {
            gl.glEnable(GL_BLEND);
        }

        if (blendFunc != GL_ONE_MINUS_SRC_ALPHA) {
            gl.glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
        }

        gl.glUseProgram(prog);
        gl.glUniform1i(uTex, 0);
        gl.glActiveTexture(GL.GL_TEXTURE0);

        gl.glBindBuffer(GL.GL_ARRAY_BUFFER, vbo);
        gl.glEnableVertexAttribArray(aPos);
        gl.glEnableVertexAttribArray(aUV);
        gl.glVertexAttribPointer(aPos, 2, GL.GL_FLOAT, false, FLOATS_PER_VERTEX * Float.BYTES, 0);
        gl.glVertexAttribPointer(aUV,  2, GL.GL_FLOAT, false, FLOATS_PER_VERTEX * Float.BYTES, 2 * Float.BYTES);

        final Node[] nodes = nodesCallback.getNodesArray();
        final int count = nodesCallback.getCount();
        if (nodes == null || count <= 0) {
            // Clean state
            gl.glDisableVertexAttribArray(aPos);
            gl.glDisableVertexAttribArray(aUV);
            gl.glBindBuffer(GL.GL_ARRAY_BUFFER, 0);
            gl.glBindTexture(GL.GL_TEXTURE_2D, 0);
            gl.glUseProgram(0);
            return;
        }

        // Build per-atlas-page draw lists
        final Map<AtlasPage, BatchedVertices> batches = new LinkedHashMap<>();

        for (int i = 0; i < count; i++) {
            final Node n = nodes[i];
            if (n == null) continue;

            if (someSelection && !selection.isNodeSelected(n)) {
                continue;
            }

            final String text = n.getLabel();
            if (text == null || text.isEmpty()) continue;

            // world -> clip -> NDC
            final float[] clip = mulMV(mvp, n.x(), n.y(), 0f, 1f);
            if (!isFinite(clip[3]) || clip[3] == 0f) continue;
            final float ndcX = clip[0] / clip[3];
            final float ndcY = clip[1] / clip[3];
            if (!isFinite(ndcX) || !isFinite(ndcY)) continue;

            // NDC -> screen (top-left)
            final float cx = (ndcX * 0.5f + 0.5f) * W;
            final float cy = (1f - (ndcY * 0.5f + 0.5f)) * H;
            if (!isFinite(cx) || !isFinite(cy)) continue;

            // node diameter in px
            final float ppwu = pixelsPerWorldUnitAt(n.x(), n.y(), mvp, W, H);
            if (ppwu <= 0 || !isFinite(ppwu)) continue;
            final float nodeDiameterPx = Math.max(1f, 2f * n.size() * ppwu) * 4f;

            // label height (bucketed + clamped)
            int pxHeight = Math.round(nodeDiameterPx * LABEL_HEIGHT_TO_DIAMETER);
            if (pxHeight <= 0 || !isFinite(nodeDiameterPx)) continue;
            pxHeight = Math.min(MAX_LABEL_PX_HEIGHT, Math.max(10, bucketPx(pxHeight)));

            final int argb = 0xff000000; // TODO color per node if desired

            // Fetch/create sprite in atlas (with downscaled raster)
            final LabelSprite sprite = cache.getOrCreate(gl, fontCollection, paragraphStyle,
                    text, pxHeight, argb, RASTER_SCALE, USE_MIPMAPS);
            if (sprite == null) continue;

            // clamp draw width to node diameter
            final float maxW = nodeDiameterPx * LABEL_MAX_WIDTH_FILL;
            final float drawW = Math.min(sprite.logicalW, maxW);
            final float scale = sprite.logicalW > 0 ? drawW / sprite.logicalW : 1f;
            final float drawH = sprite.logicalH * scale;
            if (!(drawW > 0 && drawH > 0) || !isFinite(drawW) || !isFinite(drawH)) continue;

            // center quad at (cx, cy)
            final float x0 = cx - drawW * 0.5f;
            final float y0 = cy - drawH * 0.5f;
            final float x1 = x0 + drawW;
            final float y1 = y0 + drawH;

            // to NDC
            final float x0n =  (x0 / W) * 2f - 1f;
            final float x1n =  (x1 / W) * 2f - 1f;
            final float y0n =  1f - (y0 / H) * 2f;
            final float y1n =  1f - (y1 / H) * 2f;

            if (!isFinite(x0n) || !isFinite(x1n) || !isFinite(y0n) || !isFinite(y1n)) continue;

            // Append to this page's batch as TRIANGLES (two faces per quad, 6 vertices)
            BatchedVertices bv = batches.computeIfAbsent(sprite.page, k -> new BatchedVertices());
            final float u0 = sprite.u0, v0 = sprite.v0, u1 = sprite.u1, v1 = sprite.v1;
            bv.putQuad(
                    x0n, y0n, u0, v1,
                    x0n, y1n, u0, v0,
                    x1n, y1n, u1, v0,
                    x0n, y0n, u0, v1,
                    x1n, y1n, u1, v0,
                    x1n, y0n, u1, v1
            );
        }

        // Draw per page
        for (Map.Entry<AtlasPage, BatchedVertices> e : batches.entrySet()) {
            final AtlasPage page = e.getKey();
            final BatchedVertices bv = e.getValue();
            final int vertCount = bv.vertexCount();
            if (vertCount <= 0) continue;

            // Orphan & upload
            final ByteBuffer src = bv.flipView();
            final int byteCount = src.remaining();
            gl.glBufferData(GL.GL_ARRAY_BUFFER, byteCount, null, GL2ES2.GL_STREAM_DRAW); // orphan
            gl.glBufferSubData(GL.GL_ARRAY_BUFFER, 0, byteCount, src);

            // Bind texture and draw
            gl.glBindTexture(GL.GL_TEXTURE_2D, page.texId);
            gl.glDrawArrays(GL.GL_TRIANGLES, 0, vertCount);
        }

        //Restore state:
        if (!blendEnabled) {
            gl.glDisable(GL_BLEND);
        }
        if (blendFunc != GL_ONE_MINUS_SRC_ALPHA) {
            gl.glBlendFunc(GL_SRC_ALPHA, blendFunc);
        }

        // Clean state
        gl.glDisableVertexAttribArray(aPos);
        gl.glDisableVertexAttribArray(aUV);
        gl.glBindBuffer(GL.GL_ARRAY_BUFFER, 0);
        gl.glBindTexture(GL.GL_TEXTURE_2D, 0);
        gl.glUseProgram(0);
    }

    @Override public EnumSet<RenderingLayer> getLayers() { return LAYERS; }
    @Override public int getOrder() { return Constants.RENDERING_ORDER_LABELS; }
    @Override public String getCategory() { return PipelineCategory.NODE_LABEL; }
    @Override public int getPreferenceInCategory() { return 0; }
    @Override public String getName() { return "Node Labels (Skija cached, atlas-batched)"; }

    // ---------- GL mini-pipeline ----------

    private static int buildProgram(GL2ES2 gl, String vsSrc, String fsSrc) {
        int vs = gl.glCreateShader(GL2ES2.GL_VERTEX_SHADER);
        gl.glShaderSource(vs, 1, new String[]{vsSrc}, new int[]{vsSrc.length()}, 0);
        gl.glCompileShader(vs); checkShader(gl, vs);

        int fs = gl.glCreateShader(GL2ES2.GL_FRAGMENT_SHADER);
        gl.glShaderSource(fs, 1, new String[]{fsSrc}, new int[]{fsSrc.length()}, 0);
        gl.glCompileShader(fs); checkShader(gl, fs);

        int prog = gl.glCreateProgram();
        gl.glAttachShader(prog, vs);
        gl.glAttachShader(prog, fs);
        gl.glBindAttribLocation(prog, 0, "aPos");
        gl.glBindAttribLocation(prog, 1, "aUV");
        gl.glLinkProgram(prog); checkProgram(gl, prog);
        gl.glDeleteShader(vs); gl.glDeleteShader(fs);
        return prog;
    }

    private static void checkShader(GL2ES2 gl, int s) {
        int[] ok = new int[1];
        gl.glGetShaderiv(s, GL2ES2.GL_COMPILE_STATUS, ok, 0);
        if (ok[0] == GL.GL_FALSE) {
            int[] len = new int[1];
            gl.glGetShaderiv(s, GL2ES2.GL_INFO_LOG_LENGTH, len, 0);
            byte[] log = new byte[Math.max(len[0], 1)];
            gl.glGetShaderInfoLog(s, log.length, null, 0, log, 0);
            throw new RuntimeException("Shader compile error: " + new String(log));
        }
    }

    private static void checkProgram(GL2ES2 gl, int p) {
        int[] ok = new int[1];
        gl.glGetProgramiv(p, GL2ES2.GL_LINK_STATUS, ok, 0);
        if (ok[0] == GL.GL_FALSE) {
            int[] len = new int[1];
            gl.glGetProgramiv(p, GL2ES2.GL_INFO_LOG_LENGTH, len, 0);
            byte[] log = new byte[Math.max(len[0], 1)];
            gl.glGetProgramInfoLog(p, log.length, null, 0, log, 0);
            throw new RuntimeException("Program link error: " + new String(log));
        }
    }

    private static final String VERT_SRC ="attribute vec2 aPos;" +
        "attribute vec2 aUV;" +
        "varying vec2 vUV;" +
        "void main(){ vUV = aUV; gl_Position = vec4(aPos, 0.0, 1.0); }";

    private static final String FRAG_SRC = "precision mediump float;" +
        "uniform sampler2D uTex;" +
        "varying vec2 vUV;" +
        "void main(){ gl_FragColor = texture2D(uTex, vUV); }";

    // ---------- Atlas-backing cache ----------

    private static final class LabelSprite {
        final AtlasPage page;  // owner texture page
        final float logicalW, logicalH; // full logical size (px)
        final float u0, v0, u1, v1;     // UVs inside page (0..1), already padded + half-texel corrected
        LabelSprite(AtlasPage page, float logicalW, float logicalH, float u0, float v0, float u1, float v1) {
            this.page = page; this.logicalW = logicalW; this.logicalH = logicalH;
            this.u0 = u0; this.v0 = v0; this.u1 = u1; this.v1 = v1;
        }
    }

    private static final class LabelAtlasCache {
        private final int maxEntries;
        private final int pageW, pageH, pad;
        private final boolean useMipmaps = USE_MIPMAPS;

        // LRU cache from key -> sprite
        private final LinkedHashMap<String, LabelSprite> map = new LinkedHashMap<>(256, 0.75f, true) {
            @Override protected boolean removeEldestEntry(Map.Entry<String, LabelSprite> e) {
                return size() > maxEntries; // eviction from map; texture remains in page until page is cleared
            }
        };

        // active pages
        private final List<AtlasPage> pages = new ArrayList<>();

        LabelAtlasCache(int maxEntries, int pageW, int pageH, int pad) {
            this.maxEntries = Math.max(64, maxEntries);
            this.pageW = Math.max(64, pageW);
            this.pageH = Math.max(64, pageH);
            this.pad = Math.max(0, pad);
        }

        private static String key(String text, int pxHeight, int argb, float scale) {
            return pxHeight + "|" + argb + "|" + scale + "|" + text;
        }

        private int effectivePad() { return useMipmaps ? Math.max(pad, 2) : pad; }

        LabelSprite getOrCreate(GL2ES2 gl, FontCollection fonts, ParagraphStyle paraStyle,
                                String text, int pxHeight, int argbColor, float rasterScale, boolean mipmaps) {
            final String k = key(text, pxHeight, argbColor, rasterScale);
            LabelSprite sprite = map.get(k);
            if (sprite != null && sprite.page != null && sprite.page.isAlive()) return sprite;

            Paragraph p = null;
            float logicalW = 0f, logicalH = 0f;
            try {
                final TextStyle ts = new TextStyle();
                ts.setFontSize(pxHeight);
                ts.setColor(argbColor);

                final ParagraphBuilder pb = new ParagraphBuilder(paraStyle, fonts);
                pb.pushStyle(ts);
                pb.addText(text);
                p = pb.build();
                p.layout(Float.MAX_VALUE);

                logicalW = (float) Math.ceil(p.getMaxIntrinsicWidth());
                logicalH = (float) Math.ceil(p.getHeight());
            } catch (Throwable t) {
                if (p != null) try { p.close(); } catch (Throwable ignore) {}
                return null;
            }
            if (!(logicalW > 0 && logicalH > 0) || !isFinite(logicalW) || !isFinite(logicalH)) {
                if (p != null) try { p.close(); } catch (Throwable ignore) {}
                return null;
            }

            final int texW = Math.max(1, Math.round(logicalW * rasterScale));
            final int texH = Math.max(1, Math.round(logicalH * rasterScale));

            final int needW = texW + effectivePad() * 2;
            final int needH = texH + effectivePad() * 2;

            AtlasPage page = findPageWithRoom(gl, needW, needH, mipmaps);
            if (page == null) {
                if (p != null) try { p.close(); } catch (Throwable ignore) {}
                return null;
            }

            AtlasPage.Placement place = page.alloc(needW, needH);
            if (place == null) {
                AtlasPage np = new AtlasPage(gl, pageW, pageH, mipmaps);
                if (!np.isAlive()) {
                    if (p != null) try { p.close(); } catch (Throwable ignore) {}
                    return null;
                }
                pages.add(np);
                place = np.alloc(needW, needH);
                if (place == null) {
                    if (p != null) try { p.close(); } catch (Throwable ignore) {}
                    return null;
                }
                page = np;
            }

            final int dstX = place.x + effectivePad();
            final int dstY = place.y + effectivePad();

            Surface surface = null; Image img = null; Pixmap pm = null;
            try {
                surface = Surface.makeRasterN32Premul(texW, texH);
                final Canvas canvas = surface.getCanvas();
                canvas.clear(0x00000000);
                canvas.scale(rasterScale, rasterScale);
                p.paint(canvas, 0, 0);

                img = surface.makeImageSnapshot();
                pm = new Pixmap();
                if (!img.peekPixels(pm)) {
                    return null;
                }

                final int rowBytes = pm.getRowBytes();
                final ByteBuffer src = pm.getBuffer();
                final ByteBuffer tight = ByteBuffer.allocateDirect(texW * texH * 4).order(ByteOrder.nativeOrder());
                final byte[] row = new byte[texW * 4];
                for (int y = 0; y < texH; y++) {
                    src.position(y * rowBytes).get(row, 0, texW * 4);
                    tight.position((texH - 1 - y) * texW * 4).put(row, 0, texW * 4);
                }
                tight.rewind();

                gl.glBindTexture(GL.GL_TEXTURE_2D, page.texId);
                gl.glPixelStorei(GL.GL_UNPACK_ALIGNMENT, 1);
                gl.glTexSubImage2D(GL.GL_TEXTURE_2D, 0, dstX, dstY, texW, texH, GL.GL_RGBA, GL.GL_UNSIGNED_BYTE, tight);
                if (useMipmaps) gl.glGenerateMipmap(GL.GL_TEXTURE_2D);
                gl.glBindTexture(GL.GL_TEXTURE_2D, 0);
            } catch (Throwable t) {
                return null;
            } finally {
                if (pm != null) try { pm.close(); } catch (Throwable ignore) {}
                if (img != null) try { img.close(); } catch (Throwable ignore) {}
                if (surface != null) try { surface.close(); } catch (Throwable ignore) {}
                if (p != null) try { p.close(); } catch (Throwable ignore) {}
            }

            final float halfU = 0.5f / page.w;
            final float halfV = 0.5f / page.h;
            final float u0 = (dstX + halfU) / page.w;
            final float v0 = (dstY + halfV) / page.h;
            final float u1 = (dstX + texW - halfU) / page.w;
            final float v1 = (dstY + texH - halfV) / page.h;

            sprite = new LabelSprite(page, logicalW, logicalH, u0, v0, u1, v1);
            map.put(k, sprite);
            return sprite;
        }

        private AtlasPage findPageWithRoom(GL2ES2 gl, int needW, int needH, boolean mipmaps) {
            if (needW > pageW || needH > pageH) return null; // impossible to fit
            for (AtlasPage p : pages) {
                if (p.canFit(needW, needH)) return p;
            }
            // allocate new page
            AtlasPage np = new AtlasPage(gl, pageW, pageH, mipmaps);
            if (!np.isAlive()) return null;
            pages.add(np);
            return np;
        }

        void clear(GL2ES2 gl) {
            for (AtlasPage p : pages) p.dispose(gl);
            pages.clear();
            map.clear();
        }
    }

    private static final class AtlasPage {
        final int texId; final int w; final int h; private boolean alive = true;
        // Simple shelf bin packer (top-left origin)
        int curX = 0, curY = 0, shelfH = 0;

        AtlasPage(GL2ES2 gl, int w, int h, boolean mipmaps) {
            this.w = w; this.h = h;
            final int[] id = new int[1];
            gl.glGenTextures(1, id, 0);
            texId = id[0];
            gl.glBindTexture(GL.GL_TEXTURE_2D, texId);
            gl.glPixelStorei(GL.GL_UNPACK_ALIGNMENT, 1);
            gl.glTexParameteri(GL.GL_TEXTURE_2D, GL.GL_TEXTURE_MIN_FILTER, mipmaps ? GL.GL_LINEAR_MIPMAP_LINEAR : GL.GL_LINEAR);
            gl.glTexParameteri(GL.GL_TEXTURE_2D, GL.GL_TEXTURE_MAG_FILTER, GL.GL_LINEAR);
            gl.glTexParameteri(GL.GL_TEXTURE_2D, GL.GL_TEXTURE_WRAP_S, GL.GL_CLAMP_TO_EDGE);
            gl.glTexParameteri(GL.GL_TEXTURE_2D, GL.GL_TEXTURE_WRAP_T, GL.GL_CLAMP_TO_EDGE);
            // Allocate empty page
            gl.glTexImage2D(GL.GL_TEXTURE_2D, 0, GL.GL_RGBA, w, h, 0, GL.GL_RGBA, GL.GL_UNSIGNED_BYTE, null);
            if (mipmaps) gl.glGenerateMipmap(GL.GL_TEXTURE_2D);
            gl.glBindTexture(GL.GL_TEXTURE_2D, 0);
        }

        boolean canFit(int needW, int needH) {
            if (!alive) return false;
            if (needW <= 0 || needH <= 0) return false;
            if (curX + needW <= w && curY + needH <= h) return true;
            // try new shelf
            if (curY + shelfH + needH <= h && needW <= w) return true;
            return false;
        }

        static final class Placement { final int x,y,w,h; Placement(int x,int y,int w,int h){this.x=x;this.y=y;this.w=w;this.h=h;} }

        Placement alloc(int needW, int needH) {
            if (!canFit(needW, needH)) return null;
            // Fits current shelf?
            if (curX + needW <= w) {
                Placement p = new Placement(curX, curY, needW, needH);
                curX += needW;
                shelfH = Math.max(shelfH, needH);
                return p;
            }
            // Start new shelf
            curY += shelfH;
            curX = 0;
            shelfH = 0;
            if (!canFit(needW, needH)) return null; // double-check after moving
            Placement p = new Placement(curX, curY, needW, needH);
            curX += needW;
            shelfH = Math.max(shelfH, needH);
            return p;
        }

        boolean isAlive() { return alive; }

        void dispose(GL2ES2 gl) {
            if (!alive) return;
            gl.glDeleteTextures(1, new int[]{texId}, 0);
            alive = false;
        }
    }

    private static final class BatchedVertices {
        private ByteBuffer buffer = ByteBuffer.allocateDirect(16 * 1024).order(ByteOrder.nativeOrder());
        private int verts = 0;
        void putQuad(float... v) {
            final int need = v.length * Float.BYTES;
            if (buffer.remaining() < need) grow(Math.max(buffer.capacity() * 2, buffer.capacity() + need));
            for (float f : v) buffer.putFloat(f);
            verts += v.length / FLOATS_PER_VERTEX;
        }
        int vertexCount() { return verts; }
        ByteBuffer flipView() {
            final int lim = buffer.position();
            ByteBuffer dup = buffer.duplicate();
            dup.position(0);
            dup.limit(lim);
            ByteBuffer slice = dup.slice().order(ByteOrder.nativeOrder());
            return slice;
        }
        private void grow(int newCap) {
            final ByteBuffer nb = ByteBuffer.allocateDirect(newCap).order(ByteOrder.nativeOrder());
            buffer.flip(); nb.put(buffer); buffer = nb;
        }
    }

    // ---------- math & utils ----------

    private static void multiply4x4(float[] a, float[] b, float[] out) {
        for (int c = 0; c < 4; c++) {
            int k = c * 4;
            float b0 = b[k], b1 = b[k+1], b2 = b[k+2], b3 = b[k+3];
            out[k]   = a[0]*b0 + a[4]*b1 + a[8 ]*b2 + a[12]*b3;
            out[k+1] = a[1]*b0 + a[5]*b1 + a[9 ]*b2 + a[13]*b3;
            out[k+2] = a[2]*b0 + a[6]*b1 + a[10]*b2 + a[14]*b3;
            out[k+3] = a[3]*b0 + a[7]*b1 + a[11]*b2 + a[15]*b3;
        }
    }

    private static float[] mulMV(float[] m, float x, float y, float z, float w) {
        return new float[]{
                m[0]*x + m[4]*y + m[8 ]*z + m[12]*w,
                m[1]*x + m[5]*y + m[9 ]*z + m[13]*w,
                m[2]*x + m[6]*y + m[10]*z + m[14]*w,
                m[3]*x + m[7]*y + m[11]*z + m[15]*w
        };
    }

    private static boolean isFinite(float v) { return !Float.isNaN(v) && !Float.isInfinite(v); }

    private static int bucketPx(int px) { return Math.max(8, (px + SIZE_BUCKET_PX/2) / SIZE_BUCKET_PX * SIZE_BUCKET_PX); }

    private static float pixelsPerWorldUnitAt(float x, float y, float[] mvp, int vpW, int vpH) {
        final float[] p0 = mulMV(mvp, x,   y,   0f, 1f);
        final float[] p1 = mulMV(mvp, x+1, y,   0f, 1f);
        final float nx0 = p0[0]/p0[3], ny0 = p0[1]/p0[3];
        final float nx1 = p1[0]/p1[3], ny1 = p1[1]/p1[3];
        final float sx0 = (nx0*0.5f+0.5f)*vpW, sy0 = (1f - (ny0*0.5f+0.5f))*vpH;
        final float sx1 = (nx1*0.5f+0.5f)*vpW, sy1 = (1f - (ny1*0.5f+0.5f))*vpH;
        return (float) Math.hypot(sx1 - sx0, sy1 - sy0);
    }

    public void dispose(JOGLRenderingTarget target) {
        final GL2ES2 gl = target.getDrawable().getGL().getGL2ES2();
        if (gl == null) return;
        cache.clear(gl);
        if (vbo != 0) { gl.glDeleteBuffers(1, new int[]{vbo}, 0); vbo = 0; }
        if (prog != 0) { gl.glDeleteProgram(prog); prog = 0; }
    }
}
